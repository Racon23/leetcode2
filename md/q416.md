# 416. 分割等和子集
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
 

示例 2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.

# 用例
```
[1, 5, 11, 5]
[1, 2, 3, 5]
```


# 题解

先算总和，然后除2，得到target

如果可以累加到该数，则可以

贪心算法，从大到小
X 典型的np完全问题，贪心必错，只能动态规划

## 动态规划

二维数组存记录dp[n][target+1]，存ture false，默认全部false

n为前n个数中选取若干个(与这里的n target,i j 无关，可不管多少个)，target+1为若干数总和等于该值

- 对于dp[i][0]，可理解为前i个数中，总和为0，可知选取了0个数，所以这里都是true
- 对于dp[0][j]，可理解为在下标为i==0时，该值是多少，比如nums[0]=4,那么dp[0][4]=true，其他dp[0][j]=false;

- 对于nums[i]>j，不可以选取，dp[i][j]=dp[i-1][j]

- 对于nums[i]<=j，
  - 选取，dp[i][j]=dp[i-1][j-nums[i]]
  - 不选，dp[i][j] = dp[i-1][j]

可得公式

dp[i][j] = dp[i-1][j]|dp[i-1][j-nums[i]],nums<=j
         = dp[i-1][j],nums > j

进阶

可看出,dp[i][j]只与dp[i-1][j]有关，而且或运算可统一处理

简略一下，dp[j]=dp[j]|dp[j-nums[i]]

要从大到小迭代，因为如果从小到大，比如i==2时，更新dp[2]前，已经更新了dp[1]，那么i==2时的dp[2]是与i==1时的dp[1]有关，而不是与上一行，当i==1时的dp[1]有关。


特殊条件
maxnum大于target，必定false

n < 2，必定false

sum是奇数，必定false










