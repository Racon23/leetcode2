# 621. 任务调度器
给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

示例 1：

输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
示例 2：

输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类
示例 3：

输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
 

提示：

1 <= task.length <= 104
tasks[i] 是大写英文字母
n 的取值范围为 [0, 100]

# 用例
```
["A","A","A","B","B","B"]
2
["A","A","A","B","B","B"]
0
["A","A","A","A","A","A","B","C","D","E","F","G"]
2
["A","A","A","B","B","B", "C","C","C", "D", "D", "E"]
2
["A","B","C","D","A","B","V"]
3
["A","B","A","B"]
2
["A","B","C","A"]
2

```

# 题解

## 插隙

哈希表统计各任务个数，

用最大个数的任务筑底

分两种情况

- A能独自筑底

条件是 maxcount * (n+1) >len

判断有无其他数与a的数量一样，放到后面
先把尾巴组好，a3 b3, _ _ _ _ a b

填数，填剩下到塞到尾巴后面

maxcount-1 * n+1 >= len - k,k是已经填到末尾的数，也就是和maxcount相等的次数

是，就除了末尾就能填充完所有数
否，要加上末尾才能填充完

- A不能独自筑底

a2 b2 c d e f

a _ a _ b _ b _

a3 b c

["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2

A 6
B 1
C 1
D 1
E 1
F 1
G 1

A       A       A       A       A       A
A B  C    A  D  E   A  F  G   A       A       A


["A","A","A","B","B","B"], n = 2

A  B     A  B     A B

["A","B","C","D","A","B","V"] n = 3





## 贪心 不行，还是要用插隙

